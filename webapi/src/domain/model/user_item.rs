// DON'T EDIT. this code is generated by nene.
use google_cloud_googleapis::spanner::v1::Mutation;

use google_cloud_spanner::client::RunInTxError;
use google_cloud_spanner::key::Key;
use google_cloud_spanner::mutation::{delete, insert_or_update_struct, insert_struct, replace_struct, update_struct};

use google_cloud_spanner::statement::{Statement, ToKind};
use google_cloud_spanner::transaction::CallOptions;
use google_cloud_spanner::transaction::Transaction;

use crate::domain::model::read_by_statement;
use google_cloud_spanner_derive::Table;
use serde::Serialize;
use tracing::instrument;

pub const TABLE_NAME: &str = "UserItem";
pub const COLUMN_USER_ID: &str = "UserId";
pub const COLUMN_ITEM_ID: &str = "ItemId";
pub const COLUMN_QUANTITY: &str = "Quantity";
pub const COLUMN_UPDATED_AT: &str = "UpdatedAt";

#[derive(Clone, Debug, Table, Default, Serialize)]
pub struct UserItem {
    pub user_id: String,
    pub item_id: i64,
    pub quantity: i64,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl UserItem {
    pub fn insert(&self) -> Mutation {
        insert_struct(TABLE_NAME, self)
    }

    pub fn update(&self) -> Mutation {
        update_struct(TABLE_NAME, self)
    }

    pub fn replace(&self) -> Mutation {
        replace_struct(TABLE_NAME, self)
    }

    pub fn insert_or_update(&self) -> Mutation {
        insert_or_update_struct(TABLE_NAME, self)
    }

    pub fn delete(&self) -> Mutation {
        delete(TABLE_NAME, Key::composite(&[&self.user_id, &self.item_id]))
    }

    #[instrument(skip_all)]
    pub async fn read_by_user_id(
        tx: &mut Transaction,
        user_id: &str,
        options: Option<CallOptions>,
    ) -> Result<Vec<Self>, RunInTxError> {
        let mut stmt = Statement::new("SELECT * From UserItem WHERE UserId = @UserId");
        stmt.add_param(COLUMN_USER_ID, &user_id);
        read_by_statement(tx, stmt, options).await
    }

    #[instrument(skip_all)]
    pub async fn find_by_pk(
        tx: &mut Transaction,
        user_id: &str,
        item_id: &i64,
        options: Option<CallOptions>,
    ) -> Result<Option<Self>, RunInTxError> {
        let mut stmt = Statement::new("SELECT * From UserItem WHERE UserId = @UserId AND ItemId = @ItemId");
        stmt.add_param(COLUMN_USER_ID, &user_id);
        stmt.add_param(COLUMN_ITEM_ID, item_id);
        let mut rows = read_by_statement(tx, stmt, options).await?;
        if !rows.is_empty() {
            Ok(rows.pop())
        } else {
            Ok(None)
        }
    }
}
